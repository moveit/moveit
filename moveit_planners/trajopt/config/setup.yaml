trajopt_param:
  improve_ratio_threshold: 0.25   # minimum ratio true_improve/approx_improve to accept step
  min_trust_box_size: 1e-4        # if trust region gets any smaller, exit and report convergence
  min_approx_improve: 1e-4        # if model improves less than this, exit and report convergence
  min_approx_improve_frac: -.Inf  # if model improves less than this, exit and report convergence
  max_iter: 100                   # The max number of iterations
  trust_shrink_ratio: 0.1         # if improvement is less than improve_ratio_threshold, shrink trust region by this ratio
  trust_expand_ratio: 1.5         # if improvement is less than improve_ratio_threshold, shrink trust region by this ratio
  cnt_tolerance: 1e-4             # after convergence of penalty subproblem, if constraint violation is less than this, we're done
  max_merit_coeff_increases: 5    # number of times that we jack up penalty coefficient
  merit_coeff_increase_ratio: 10  # ratio that we increate coeff each time
  max_time: .inf                  # not yet implemented
  merit_error_coeff: 10           # initial penalty coefficient
  trust_box_size: 1e-1            # current size of trust region (component-wise)

problem_info:
  basic_info:
    n_steps: 20                # 2 * steps_per_phase
    dt_upper_lim: 2.0          # The upper limit of 1/dt values allowed in the optimization
    dt_lower_lim: 100.0        # The lower limit of 1/dt values allowed in the optimization
    start_fixed: true          # if true, start pose is the current pose and the req.start_state is ignored
    # if false, the start pose is the one given by req.start_state
    use_time: flase            # if false, it means the timestep is unit, meaning x1-x0 is the velocity for example
    # if true, then cost_infos ro cnt_infos should have TT_USE_TIME for their term_type
    convex_solver: 1           # which convex solver to use
    #  1 = AUTO_SOLVER,  2 = BPMPD, 3 = OSQP, 4 = QPOASES, 5 = GUROBI

  init_info:
    type: 2                    # 1 = STATIONARY, 2 = JOINT_INTERPOLATED, 3 = GIVEN_TRAJ
    # request.start_state should be provided for JOINT_INTERPOLATED and GIVEN_TRAJ
    dt: 0.5

joint_pos_term_info:
  start_pos:
    name: start_pos
    first_timestep: 0                # First time step to which the term is applied.
    last_timestep: 0                # Last time step to which the term is applied. n_steps - 1
    term_type: 2                 # 1 = TT_COST, 2 = TT_CNT, 3 = TT_USE_TIME
  middle_pos:
    name: middle_pos
    first_timestep: 10                # First time step to which the term is applied.
    last_timestep: 10                # Last time step to which the term is applied. n_steps - 1
    term_type: 2                 # 1 = TT_COST, 2 = TT_CNT, 3 = TT_USE_TIME
  goal_pos:
    name: goal_pos
    first_timestep: 19                # First time step to which the term is applied.
    last_timestep: 19                # Last time step to which the term is applied. n_steps - 1
    term_type: 2                 # 1 = TT_COST, 2 = TT_CNT, 3 = TT_USE_TIME
